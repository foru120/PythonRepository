# 01. == 과 is 연산의 차이점
a=100
b=100
print("a :",a,", b :",b,", id(a) :",id(a),", id(b) :",id(b))
print("a == b :",a==b,", a is b :",a is b)
c=10000000
d=10000000
print("c :",c,", d :",d,", id(c) :",id(c),", id(d) :",id(d))
print("c == d :",c==d,", c is d :",c is d)
'''
    == 연산은 해당 변수의 값을 비교하는 연산이고, is 연산은 해당 변수의 id 를 비교하는 연산.
    파이썬은 -5~256 사이의 숫자는 메모리에 한 번만 생성되고 해당 값을 모든 변수들이 공유해서 사용.
    책에서는 -5~256 사이의 숫자만 공유한다고 나오는데 테스트 결과 같은 값은 메모리상에 하나만 생성한채 공유해서 사용.
'''    


# 02. 타입
# 02-01. 불리언
print(10*10==100)
print(type(True))

# 02-02. 정수
print(type(10),type(0),type(-19)) #양의 정수, 0, 음의 정수 모두 int 타입 클래스
print(0b10,0o777,0xdf23) #0b:2진수, 0o:8진수, 0x:16진수

# 02-03. 실수
print(0.1*0.1==0.01) #부동소수점 연산의 한계로 인해 오차가 발생해서 두 값이 같지 않다
print("0.1*0.1 :",0.1*0.1,", 0.01 :",0.01)
print(type(3.141592),type(3141592e-6))
print(3.141592,3141592e-6,3.141592==3141592e-6)

# 02-04. 복소수(실수부와 허수부가 존재하는 수)
print(7+7j,type(7+7j),7+7j+3,7+7j+3j)

# 02-05. 타입 변경
print(int(True),bool(108),float(77),int(3.14),complex(0))
print(str(77)) #int 타입에서 str 타입으로 변경 가능
# print(tuple(77)) #int 타입에서 tuple 타입으로 변경 불가능


# 03. 연산
# 03-01. 숫자 연산
print(1024+1024,1024-24,1024*3,1024/256) #_는 이전 계산값을 기억하는 임시변수로 사용 가능(파이썬 쉘에서)
print(7//4,2**10,10%7,1000<1024) #몫, 승수, 나머지, 비교
print(divmod(10,3)) #divmod 함수는 몫과 나머지를 튜플 형태로 출력
x=3
x-=1; print(x);
x/=2; print(x);
x*=77; print(x);
x//=7; print(x);
# 파이썬 3.x 버전은 정수와 정수의 나눗셈 결과가 실수로 표현되는데, 2.x 버전은 무조건 정수로 표현된다.(소수점 이하는 버림)

# 03-02. 쉬프트 연산
print((0b11 << 2 == 0b1100)) #<<(왼쪽으로 비트 이동, 빈 공간은 0으로 채워짐)
print((0b11 >> 1 == 0b1)) #>>(오른쪽으로 비트 이동, 비트 이동을 한 만큼 비트가 버려짐)
a=1
print(a<<1)
print(a<<2)
print(a<<3)
print(a<<4)
print(4>>1) #짝수의 오른쪽 쉬프트 연산은 원래의 수의 반이 됨
print(3>>1) #홀수의 오른쪽 쉬프트 연산은 원래의 수의 반이 되지 않음

# 03-03. 비트 연산
print(1&1)
print(1&0)
print(0&0)
print(0b1111 & 0b1010) #각 비트의 수가 둘다 1일 경우에만 1
print(1|1)
print(1|0)
print(0|0)
print(0b1110 | 0b1010) #각 비트의 수가 하나라도 1이면 1
print(1^1)
print(1^0)
print(0^0)
print(0b1110 ^ 0b1010) #각 비트의 수가 같으면 0, 다르면 1
print(~1)
print(~2) #not 연산은 1의 보수를 구하는 것과 같다(2:0b010, ~2:0b10)

# 03-04. 논리 연산
print(1 and 1)
print(1 and 0)
print(0 and 1)
print(0 and 0)
print(10 and 20)
print(20 and 10)
print(0 and 10)
print(0 and 1234)
print(9 and 3.14) #좌항이 0이 아니면 결과값은 우항, 좌항이 0이면 결과값은 좌항
print(10 or 20)
print(20 or 10)
print(0 or 10)
print(0 or 1234)
print(9 or 3.14) #좌항이 0이 아니면 결과값은 좌항, 좌항이 0이면 결과값은 우항
print(not 0)
print(not 10)
print(not True)
print(not False) #not 연산자는 True->False, False->True 변환
x=2;y=3
x,y=y,x
print(x, y)


# 직접해 봅시다
# 1. 파이썬 2.x 버전과 파이썬 3.x 버전에서 숫자 간 나눗셈을 했을 때의 차이점에 대해 설명해보자.
#  - 2.x 버전에서 정수끼리의 나눗셈 결과는 소수점은 버린채 정수로만 출력되지만, 3.x 버전에서는 결과가 실수로 출력되어 값의 버림이 없다.

# 2. 지수 표기법을 사용하여 3.141592를 소수점 없이 나타내보자.
print(3141592e-6)

# 3. x=15일 때 오른쪽으로 3만큼 쉬프트 연산을 하여 x의 값을 변경하는 연산을 해보자.
x=15
x >>= 3
print(x)

# 4. <<(왼편 쉬프트) 연산의 결과가 항상 짝수가 나오는 이유를 설명해보자(단 0만큼 이동한 경우를 제외한다)
#  - 2진수에서 홀수는 첫번째 비트가 1인 경우인데 왼편 쉬프트를 하게 되면 첫번째 비트가 무저건 0이 되므로 짝수가 된다.

# 5. 숫자 >> 1(오른편 쉬프트) 연산이 어떻게 원래의 수를 반으로 나누는지 설명하자. 그리고 숫자가 홀수의 경우는 어떻게 동작하는지도 설명하자.
#  - 2진수에서 오른쪽으로 1비트 이동하면 1/2 배가 되고, 홀수인 경우에는 1이 오른쪽 쉬프트 되면 해당 값이 없어지므로 1/2배가 된 상태에서 -1 인 값이 된다.

# 6. 2의 보수법으로 100은 음수로 -77은 양수로 바꿔보자.
print(~100+1)
print(~-77+1)

# 7. 다음 코드의 결과를 보고 결과의 원인을 설명해보자.
x=77; y=77
print(x is y) #파이썬 쉘에서는 -5~256까지의 숫자는 미리 생성된 객체를 재사용하므로 True가 나옴
a=1234; b=1234
print(a is b) #파이썬 쉘에서는 -5~256이외의 숫자는 값을 할당할 때마다 객체를 생성하므로 False가 나옴